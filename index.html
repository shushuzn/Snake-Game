<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è´ªåƒè›‡æ¸¸æˆ</title>
    <style>
      :root { color-scheme: dark; }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        background: radial-gradient(circle at top, #1a1a2e, #0b0b16 50%, #05050d);
        color: #f5f5f5;
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 12px;
      }
      .game-shell {
        width: min(92vw, 560px);
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 16px;
        backdrop-filter: blur(6px);
        box-shadow: 0 20px 45px rgba(0, 0, 0, 0.4);
      }
      .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 12px; }
      .header h1 { margin: 0; font-size: 1.4rem; }
      .stats { display: flex; gap: 12px; font-size: 0.9rem; flex-wrap: wrap; justify-content: end; }
      .stats b { color: #7dffa5; }
      .stats b.warn { color: #fbbf24; }
      #board {
        width: 100%; aspect-ratio: 1 / 1; border-radius: 12px;
        border: 2px solid rgba(255, 255, 255, 0.2); background: #0f1322; display: block;
      }
      .controls-row { margin-top: 12px; display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap; align-items: center; }
      .controls-group { display: inline-flex; flex-wrap: wrap; gap: 8px; align-items: center; }
      button, select { border: 0; border-radius: 10px; font-weight: 700; }
      button { background: linear-gradient(135deg, #34d399, #10b981); color: #052014; padding: 9px 14px; cursor: pointer; }
      button.secondary { background: linear-gradient(135deg, #93c5fd, #60a5fa); color: #081426; }
      .label-inline { display: inline-flex; align-items: center; gap: 6px; font-size: 0.88rem; }
      .label-inline input { accent-color: #34d399; }
      select { background: #1e293b; color: #f8fafc; padding: 7px 10px; border: 1px solid rgba(255, 255, 255, 0.18); }
      .tips { margin-top: 10px; color: #d3d3e7; font-size: 0.88rem; }
      .overlay {
        position: absolute; inset: 0; display: grid; place-items: center; text-align: center;
        padding: 12px; color: #fff; pointer-events: none; text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      }
      .board-wrap { position: relative; }
      .overlay p { margin: 4px 0; }
      .mobile-pad {
        margin: 14px auto 2px; width: 170px; display: grid;
        grid-template-columns: repeat(3, 1fr); gap: 6px; user-select: none;
      }
      .mobile-pad button { padding: 10px 0; border-radius: 8px; font-size: 18px; }
      .mobile-pad .empty { visibility: hidden; }
      @media (min-width: 700px) { .mobile-pad { display: none; } }
    </style>
  </head>
  <body>
    <main class="game-shell">
      <section class="header">
        <h1>ğŸ è´ªåƒè›‡</h1>
        <div class="stats">
          <span>åˆ†æ•°ï¼š<b id="score">0</b></span>
          <span>æœ€é«˜åˆ†ï¼š<b id="best">0</b></span>
          <span>é•¿åº¦ï¼š<b id="length">3</b></span>
          <span>æ—¶é—´ï¼š<b id="time" class="warn">--</b></span>
          <span>è¿å‡»ï¼š<b id="combo">x1</b></span>
          <span>æŠ¤ç›¾ï¼š<b id="shield">0</b></span>
        </div>
      </section>

      <div class="board-wrap">
        <canvas id="board" width="500" height="500" aria-label="è´ªåƒè›‡æ£‹ç›˜"></canvas>
        <div class="overlay" id="overlay">
          <div>
            <p><strong>æŒ‰æ–¹å‘é”®å¼€å§‹æ¸¸æˆ</strong></p>
            <p>W/A/S/Dã€è§¦å±æ–¹å‘é”®æˆ–æ»‘åŠ¨éƒ½å¯æ§åˆ¶</p>
          </div>
        </div>
      </div>

      <section class="controls-row">
        <div class="controls-group">
          <button id="restart" type="button">é‡æ–°å¼€å§‹</button>
          <button id="pause" type="button" class="secondary">æš‚åœ</button>
        </div>
        <div class="controls-group">
          <label class="label-inline" for="mode">æ¨¡å¼ï¼š
            <select id="mode"><option value="classic" selected>ç»å…¸</option><option value="timed">é™æ—¶ 60 ç§’</option></select>
          </label>
          <label class="label-inline" for="difficulty">éš¾åº¦ï¼š
            <select id="difficulty"><option value="140">æ‚ é—²</option><option value="110" selected>æ ‡å‡†</option><option value="80">æé€Ÿ</option></select>
          </label>
          <label class="label-inline" for="wrapMode"><input id="wrapMode" type="checkbox" />ç©¿å¢™</label>
          <label class="label-inline" for="obstacleMode"><input id="obstacleMode" type="checkbox" checked />éšœç¢</label>
        </div>
      </section>

      <p class="tips">æç¤ºï¼šç©ºæ ¼/P æš‚åœæˆ–ç»§ç»­ã€‚é‡‘è‰²é£Ÿç‰© +30 åˆ†ï¼Œè“è‰²é£Ÿç‰©è·å¾—æŠ¤ç›¾ï¼›è¿å‡»å’Œéšœç¢ä¼šéšåˆ†æ•°è¿›åŒ–ã€‚</p>

      <div class="mobile-pad" aria-label="ç§»åŠ¨æ§åˆ¶">
        <button class="empty" tabindex="-1"></button>
        <button data-dir="ArrowUp" aria-label="ä¸Š">â¬†ï¸</button>
        <button class="empty" tabindex="-1"></button>
        <button data-dir="ArrowLeft" aria-label="å·¦">â¬…ï¸</button>
        <button data-dir="ArrowDown" aria-label="ä¸‹">â¬‡ï¸</button>
        <button data-dir="ArrowRight" aria-label="å³">â¡ï¸</button>
      </div>
    </main>

    <script>
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const lengthEl = document.getElementById('length');
      const timeEl = document.getElementById('time');
      const comboEl = document.getElementById('combo');
      const shieldEl = document.getElementById('shield');
      const overlay = document.getElementById('overlay');
      const restartBtn = document.getElementById('restart');
      const pauseBtn = document.getElementById('pause');
      const difficultySelect = document.getElementById('difficulty');
      const modeSelect = document.getElementById('mode');
      const wrapModeInput = document.getElementById('wrapMode');
      const obstacleModeInput = document.getElementById('obstacleMode');
      const mobilePad = document.querySelector('.mobile-pad');

      const gridSize = 20;
      const tileCount = canvas.width / gridSize;
      const timedModeDuration = 60;
      const settingsKey = 'snake-settings-v2';

      const dirMap = {
        ArrowUp: { x: 0, y: -1 }, ArrowDown: { x: 0, y: 1 }, ArrowLeft: { x: -1, y: 0 }, ArrowRight: { x: 1, y: 0 },
        w: { x: 0, y: -1 }, s: { x: 0, y: 1 }, a: { x: -1, y: 0 }, d: { x: 1, y: 0 }
      };

      let snake;
      let direction;
      let pendingDirection;
      let food;
      let bonusFood = null;
      let bonusExpireAt = 0;
      let shieldFood = null;
      let shieldExpireAt = 0;
      let rocks = [];
      let score;
      let bestScore = Number(localStorage.getItem('snake-best') || '0');
      let running = false;
      let paused = false;
      let loopTimer;
      let baseSpeed = Number(difficultySelect.value);
      let speed = baseSpeed;
      let touchStart = null;
      let mode = modeSelect.value;
      let remainingTime = timedModeDuration;
      let lastTickMs = 0;
      let combo = 1;
      let lastEatMs = 0;
      let shields = 0;

      bestEl.textContent = String(bestScore);

      function loadSettings() {
        try {
          const parsed = JSON.parse(localStorage.getItem(settingsKey) || '{}');
          if (parsed.mode === 'classic' || parsed.mode === 'timed') modeSelect.value = parsed.mode;
          if (['140', '110', '80'].includes(String(parsed.difficulty))) difficultySelect.value = String(parsed.difficulty);
          wrapModeInput.checked = Boolean(parsed.wrapMode);
          obstacleModeInput.checked = parsed.obstacleMode !== false;
        } catch {
          // ignore malformed settings
        }
      }

      function saveSettings() {
        localStorage.setItem(settingsKey, JSON.stringify({
          mode: modeSelect.value,
          difficulty: difficultySelect.value,
          wrapMode: wrapModeInput.checked,
          obstacleMode: obstacleModeInput.checked
        }));
      }

      function showOverlay(message) { overlay.innerHTML = `<div>${message}</div>`; overlay.style.display = 'grid'; }
      function hideOverlay() { overlay.style.display = 'none'; }
      function updateTimeText() { timeEl.textContent = mode === 'timed' ? `${Math.max(0, Math.ceil(remainingTime))}s` : '--'; }

      function resetGame(showStartOverlay = true) {
        snake = [{ x: 8, y: 12 }, { x: 7, y: 12 }, { x: 6, y: 12 }];
        direction = { x: 1, y: 0 };
        pendingDirection = direction;
        food = randomFoodPosition();
        bonusFood = null;
        bonusExpireAt = 0;
        shieldFood = null;
        shieldExpireAt = 0;
        rocks = [];
        score = 0;
        running = false;
        paused = false;
        remainingTime = timedModeDuration;
        lastTickMs = 0;
        speed = baseSpeed;
        combo = 1;
        lastEatMs = 0;
        shields = 0;
        clearInterval(loopTimer);
        pauseBtn.textContent = 'æš‚åœ';
        scoreEl.textContent = '0';
        lengthEl.textContent = String(snake.length);
        comboEl.textContent = 'x1';
        shieldEl.textContent = '0';
        updateTimeText();
        if (showStartOverlay) showOverlay('<p><strong>æŒ‰æ–¹å‘é”®å¼€å§‹æ¸¸æˆ</strong></p><p>W/A/S/Dã€è§¦å±æ–¹å‘é”®æˆ–æ»‘åŠ¨éƒ½å¯æ§åˆ¶</p>');
        draw();
      }

      function isOnSnake(cell) { return snake.some(seg => seg.x === cell.x && seg.y === cell.y); }

      function randomFreeCell() {
        let position;
        do {
          position = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
        } while (
          isOnSnake(position) ||
          (food && food.x === position.x && food.y === position.y) ||
          (bonusFood && bonusFood.x === position.x && bonusFood.y === position.y) ||
          (shieldFood && shieldFood.x === position.x && shieldFood.y === position.y) ||
          rocks.some(rock => rock.x === position.x && rock.y === position.y)
        );
        return position;
      }

      function randomFoodPosition() { return randomFreeCell(); }

      function maybeSpawnBonusFood(now) {
        if (bonusFood || score === 0) return;
        if (score % 50 !== 0) return;
        bonusFood = randomFreeCell();
        bonusExpireAt = now + 3200;
      }

      function maybeSpawnShieldFood(now) {
        if (shieldFood || shields >= 2) return;
        if (score < 60) return;
        if (score % 70 !== 0) return;
        shieldFood = randomFreeCell();
        shieldExpireAt = now + 4500;
      }

      function maybeAddRock() {
        if (!obstacleModeInput.checked) return;
        if (score < 80) return;
        if (score % 40 !== 0) return;
        if (rocks.length >= 8) return;
        rocks.push(randomFreeCell());
      }

      function startLoop() {
        clearInterval(loopTimer);
        lastTickMs = performance.now();
        loopTimer = setInterval(update, speed);
      }

      function startGameIfNeeded() {
        if (running && !paused) return;
        if (!running) {
          running = true;
          paused = false;
          hideOverlay();
          pauseBtn.textContent = 'æš‚åœ';
          startLoop();
          return;
        }
        if (paused) {
          paused = false;
          hideOverlay();
          pauseBtn.textContent = 'æš‚åœ';
          startLoop();
        }
      }

      function changeDirection(next) {
        const isReverse = next.x === -direction.x && next.y === -direction.y;
        if (!isReverse) pendingDirection = next;
        startGameIfNeeded();
      }

      function togglePause() {
        if (!running) return;
        if (paused) return startGameIfNeeded();
        paused = true;
        clearInterval(loopTimer);
        pauseBtn.textContent = 'ç»§ç»­';
        showOverlay('<p><strong>å·²æš‚åœ</strong></p><p>æŒ‰ç©ºæ ¼ / P æˆ–â€œç»§ç»­â€æ¢å¤æ¸¸æˆ</p>');
      }

      function isCollision(head) {
        const hitWall = !wrapModeInput.checked && (head.x < 0 || head.y < 0 || head.x >= tileCount || head.y >= tileCount);
        const hitSelf = snake.some(seg => seg.x === head.x && seg.y === head.y);
        const hitRock = rocks.some(rock => rock.x === head.x && rock.y === head.y);
        return hitWall || hitSelf || hitRock;
      }

      function endGame(reasonText) {
        clearInterval(loopTimer);
        running = false;
        paused = false;

        if (score > bestScore) {
          bestScore = score;
          bestEl.textContent = String(bestScore);
          localStorage.setItem('snake-best', String(bestScore));
        }

        showOverlay(`<p><strong>${reasonText}</strong></p><p>æœ€ç»ˆå¾—åˆ† ${score}</p><p>æŒ‰æ–¹å‘é”®æˆ–ç‚¹å‡»â€œé‡æ–°å¼€å§‹â€å†æ¥ä¸€å±€</p>`);
      }

      function update() {
        const now = performance.now();
        const elapsed = lastTickMs ? (now - lastTickMs) / 1000 : 0;
        lastTickMs = now;

        if (mode === 'timed') {
          remainingTime -= elapsed;
          updateTimeText();
          if (remainingTime <= 0) return endGame('â° æ—¶é—´åˆ°ï¼');
        }

        if (bonusFood && now > bonusExpireAt) bonusFood = null;
        if (shieldFood && now > shieldExpireAt) shieldFood = null;

        direction = pendingDirection;
        const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

        if (wrapModeInput.checked) {
          if (head.x < 0) head.x = tileCount - 1;
          if (head.x >= tileCount) head.x = 0;
          if (head.y < 0) head.y = tileCount - 1;
          if (head.y >= tileCount) head.y = 0;
        }

        if (isCollision(head)) {
          if (shields > 0) {
            shields -= 1;
            shieldEl.textContent = String(shields);
          } else {
            return endGame('ğŸ’¥ æ’åˆ°äº†ï¼');
          }
        }

        snake.unshift(head);

        let ate = false;
        if (head.x === food.x && head.y === food.y) {
          ate = true;
          score += 10;
          food = randomFoodPosition();
          maybeSpawnBonusFood(now);
          maybeSpawnShieldFood(now);
        }

        if (bonusFood && head.x === bonusFood.x && head.y === bonusFood.y) {
          ate = true;
          score += 30;
          bonusFood = null;
        }

        if (shieldFood && head.x === shieldFood.x && head.y === shieldFood.y) {
          ate = true;
          shields = Math.min(2, shields + 1);
          shieldEl.textContent = String(shields);
          shieldFood = null;
        }

        if (ate) {
          const eatDelta = lastEatMs ? now - lastEatMs : Infinity;
          combo = eatDelta <= 3000 ? Math.min(combo + 1, 9) : 1;
          score += (combo - 1) * 2;
          comboEl.textContent = `x${combo}`;
          lastEatMs = now;
          maybeAddRock();
        } else if (lastEatMs && now - lastEatMs > 3000) {
          combo = 1;
          comboEl.textContent = 'x1';
        }

        if (!ate) {
          snake.pop();
        } else {
          const speedBoost = Math.floor(score / 50) * 5;
          speed = Math.max(55, baseSpeed - speedBoost);
          if (running && !paused) startLoop();
        }

        scoreEl.textContent = String(score);
        lengthEl.textContent = String(snake.length);
        draw();
      }

      function drawGrid() {
        ctx.strokeStyle = 'rgba(255,255,255,0.07)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= tileCount; i++) {
          const line = i * gridSize;
          ctx.beginPath(); ctx.moveTo(line, 0); ctx.lineTo(line, canvas.height); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0, line); ctx.lineTo(canvas.width, line); ctx.stroke();
        }
      }

      function drawCell({ x, y }, color, radius = 4) {
        const px = x * gridSize;
        const py = y * gridSize;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(px + 1, py + 1, gridSize - 2, gridSize - 2, radius);
        ctx.fill();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawCell(food, '#f472b6', 6);
        if (bonusFood) drawCell(bonusFood, '#facc15', 8);
        if (shieldFood) drawCell(shieldFood, '#38bdf8', 8);
        rocks.forEach(rock => drawCell(rock, '#64748b', 5));
        snake.forEach((segment, index) => drawCell(segment, index === 0 ? '#7dffa5' : '#22c55e'));
      }

      document.addEventListener('keydown', (event) => {
        if (event.code === 'Space' || event.key.toLowerCase() === 'p') {
          event.preventDefault();
          togglePause();
          return;
        }
        const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
        const next = dirMap[key];
        if (!next) return;
        event.preventDefault();
        changeDirection(next);
      });

      mobilePad.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-dir]');
        if (!button) return;
        changeDirection(dirMap[button.dataset.dir]);
      });

      canvas.addEventListener('touchstart', (event) => {
        const touch = event.changedTouches[0];
        touchStart = { x: touch.clientX, y: touch.clientY };
      }, { passive: true });

      canvas.addEventListener('touchend', (event) => {
        if (!touchStart) return;
        const touch = event.changedTouches[0];
        const dx = touch.clientX - touchStart.x;
        const dy = touch.clientY - touchStart.y;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        if (absX < 18 && absY < 18) { touchStart = null; return; }
        if (absX > absY) changeDirection(dx > 0 ? dirMap.ArrowRight : dirMap.ArrowLeft);
        else changeDirection(dy > 0 ? dirMap.ArrowDown : dirMap.ArrowUp);
        touchStart = null;
      }, { passive: true });

      restartBtn.addEventListener('click', () => resetGame(true));
      pauseBtn.addEventListener('click', togglePause);

      difficultySelect.addEventListener('change', () => {
        saveSettings();
        baseSpeed = Number(difficultySelect.value);
        const speedBoost = Math.floor(score / 50) * 5;
        speed = Math.max(55, baseSpeed - speedBoost);
        if (running && !paused) startLoop();
      });

      modeSelect.addEventListener('change', () => {
        saveSettings();
        mode = modeSelect.value;
        resetGame(true);
      });

      obstacleModeInput.addEventListener('change', () => { saveSettings(); resetGame(true); });
      wrapModeInput.addEventListener('change', saveSettings);

      loadSettings();
      mode = modeSelect.value;
      baseSpeed = Number(difficultySelect.value);
      resetGame(true);
    </script>
  </body>
</html>

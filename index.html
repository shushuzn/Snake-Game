<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è´ªåƒè›‡æ¸¸æˆ</title>
    <style>
      :root { color-scheme: dark; }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        background: radial-gradient(circle at top, #1a1a2e, #0b0b16 50%, #05050d);
        color: #f5f5f5;
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 12px;
      }
      .game-shell {
        width: min(92vw, 560px);
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 16px;
        backdrop-filter: blur(6px);
        box-shadow: 0 20px 45px rgba(0, 0, 0, 0.4);
      }
      .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 12px; }
      .header h1 { margin: 0; font-size: 1.4rem; }
      .header h1 small { font-size: 0.78rem; color: #93c5fd; font-weight: 600; }
      .stats { display: flex; gap: 12px; font-size: 0.9rem; flex-wrap: wrap; justify-content: end; }
      .stats b { color: #7dffa5; }
      .stats b.warn { color: #fbbf24; }
      #board {
        width: 100%; aspect-ratio: 1 / 1; border-radius: 12px;
        border: 2px solid rgba(255, 255, 255, 0.2); background: #0f1322; display: block;
      }
      .controls-row { margin-top: 12px; display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap; align-items: center; }
      .controls-group { display: inline-flex; flex-wrap: wrap; gap: 8px; align-items: center; }
      button, select { border: 0; border-radius: 10px; font-weight: 700; }
      button { background: linear-gradient(135deg, #34d399, #10b981); color: #052014; padding: 9px 14px; cursor: pointer; }
      button.secondary { background: linear-gradient(135deg, #93c5fd, #60a5fa); color: #081426; }
      .label-inline { display: inline-flex; align-items: center; gap: 6px; font-size: 0.88rem; }
      .label-inline input { accent-color: #34d399; }
      select { background: #1e293b; color: #f8fafc; padding: 7px 10px; border: 1px solid rgba(255, 255, 255, 0.18); }
      .tips { margin-top: 10px; color: #d3d3e7; font-size: 0.88rem; }
      .history { margin-top: 12px; background: rgba(15, 23, 42, 0.45); border: 1px solid rgba(255,255,255,0.12); border-radius: 10px; padding: 10px 12px; }
      .history h2 { margin: 0 0 8px; font-size: 0.95rem; color: #c7d2fe; }
      .history ol { margin: 0; padding-left: 18px; color: #dbeafe; font-size: 0.86rem; }
      .history li { margin: 2px 0; }
      .overlay {
        position: absolute; inset: 0; display: grid; place-items: center; text-align: center;
        padding: 12px; color: #fff; pointer-events: none; text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      }
      .board-wrap { position: relative; }
      .overlay p { margin: 4px 0; }
      .mobile-pad {
        margin: 14px auto 2px; width: 170px; display: grid;
        grid-template-columns: repeat(3, 1fr); gap: 6px; user-select: none;
      }
      .mobile-pad button { padding: 10px 0; border-radius: 8px; font-size: 18px; }
      .mobile-pad .empty { visibility: hidden; }
      @media (min-width: 700px) { .mobile-pad { display: none; } }
    </style>
  </head>
  <body>
    <main class="game-shell">
      <section class="header">
        <h1>ğŸ è´ªåƒè›‡ <small id="versionTag">v0.21.0</small></h1>
        <div class="stats">
          <span>åˆ†æ•°ï¼š<b id="score">0</b></span>
          <span>æœ€é«˜åˆ†ï¼š<b id="best">0</b></span>
          <span>æ¨¡å¼æœ€é«˜ï¼š<b id="modeBest">0</b></span>
          <span>é•¿åº¦ï¼š<b id="length">3</b></span>
          <span>æ—¶é—´ï¼š<b id="time" class="warn">--</b></span>
          <span>è¿å‡»ï¼š<b id="combo">x1</b></span>
          <span>æŠ¤ç›¾ï¼š<b id="shield">0</b></span>
          <span>ä»»åŠ¡ï¼š<b id="mission">--</b></span>
          <span>æ€»å±€ï¼š<b id="plays">0</b></span>
          <span>åƒåˆ°ï¼š<b id="foods">0</b></span>
          <span>è¿èƒœï¼š<b id="streak">0</b></span>
          <span>æˆå°±ï¼š<b id="achievements">0/3</b></span>
          <span>æŒ‘æˆ˜ï¼š<b id="challenge">--</b></span>
          <span>ä¸Šå±€ï¼š<b id="lastResult">--</b></span>
          <span>å€ç‡ï¼š<b id="multiplier">x1</b></span>
          <span>çŠ¶æ€ï¼š<b id="state">æ­£å¸¸</b></span>
        </div>
      </section>

      <div class="board-wrap">
        <canvas id="board" width="500" height="500" aria-label="è´ªåƒè›‡æ£‹ç›˜"></canvas>
        <div class="overlay" id="overlay">
          <div>
            <p><strong>æŒ‰æ–¹å‘é”®å¼€å§‹æ¸¸æˆ</strong></p>
            <p>W/A/S/Dã€è§¦å±æ–¹å‘é”®æˆ–æ»‘åŠ¨éƒ½å¯æ§åˆ¶</p>
          </div>
        </div>
      </div>

      <section class="controls-row">
        <div class="controls-group">
          <button id="restart" type="button">é‡æ–°å¼€å§‹</button>
          <button id="pause" type="button" class="secondary">æš‚åœ</button>
          <button id="clearData" type="button" class="secondary">æ¸…ç©ºè®°å½•</button>
          <button id="mute" type="button" class="secondary">ğŸ”Š éŸ³æ•ˆå¼€</button>
          <button id="share" type="button" class="secondary">å¤åˆ¶æˆ˜ç»©</button>
        </div>
        <div class="controls-group">
          <label class="label-inline" for="mode">æ¨¡å¼ï¼š
            <select id="mode"><option value="classic" selected>ç»å…¸</option><option value="timed">é™æ—¶ 60 ç§’</option></select>
          </label>
          <label class="label-inline" for="difficulty">éš¾åº¦ï¼š
            <select id="difficulty"><option value="140">æ‚ é—²</option><option value="110" selected>æ ‡å‡†</option><option value="80">æé€Ÿ</option></select>
          </label>
          <label class="label-inline" for="skin">çš®è‚¤ï¼š
            <select id="skin"><option value="classic" selected>ç»å…¸ç»¿</option><option value="neon">éœ“è™¹ç´«</option><option value="sunset">æ—¥è½æ©™</option><option value="pixel">åƒç´ é’</option></select>
          </label>
          <label class="label-inline" for="wrapMode"><input id="wrapMode" type="checkbox" />ç©¿å¢™</label>
          <label class="label-inline" for="obstacleMode"><input id="obstacleMode" type="checkbox" checked />éšœç¢</label>
          <label class="label-inline" for="hardcoreMode"><input id="hardcoreMode" type="checkbox" />ç¡¬æ ¸</label>
        </div>
      </section>

      <p class="tips">æç¤ºï¼šç©ºæ ¼/P æš‚åœæˆ–ç»§ç»­ã€‚æ–°å¢çš®è‚¤è£…æ‰®ï¼šå¯åˆ‡æ¢ç»å…¸/éœ“è™¹/æ—¥è½/åƒç´ é£ã€‚</p>

      <div class="mobile-pad" aria-label="ç§»åŠ¨æ§åˆ¶">
        <button class="empty" tabindex="-1"></button>
        <button data-dir="ArrowUp" aria-label="ä¸Š">â¬†ï¸</button>
        <button class="empty" tabindex="-1"></button>
        <button data-dir="ArrowLeft" aria-label="å·¦">â¬…ï¸</button>
        <button data-dir="ArrowDown" aria-label="ä¸‹">â¬‡ï¸</button>
        <button data-dir="ArrowRight" aria-label="å³">â¡ï¸</button>
      </div>

      <section class="history" aria-label="æœ€è¿‘æˆ˜ç»©">
        <h2>æœ€è¿‘æˆ˜ç»©ï¼ˆæœ€è¿‘ 5 å±€ï¼‰</h2>
        <ol id="historyList"></ol>
      </section>

      <section class="history" aria-label="é“å…·å›¾é‰´">
        <h2>é“å…·å›¾é‰´ï¼ˆå·²å‘ç° <b id="codexProgress">0/7</b>ï¼‰</h2>
        <ol id="codexList"></ol>
      </section>

    </main>

    <script>
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const modeBestEl = document.getElementById('modeBest');
      const lengthEl = document.getElementById('length');
      const timeEl = document.getElementById('time');
      const comboEl = document.getElementById('combo');
      const shieldEl = document.getElementById('shield');
      const missionEl = document.getElementById('mission');
      const playsEl = document.getElementById('plays');
      const foodsEl = document.getElementById('foods');
      const streakEl = document.getElementById('streak');
      const achievementsEl = document.getElementById('achievements');
      const challengeEl = document.getElementById('challenge');
      const lastResultEl = document.getElementById('lastResult');
      const multiplierEl = document.getElementById('multiplier');
      const stateEl = document.getElementById('state');
      const overlay = document.getElementById('overlay');
      const restartBtn = document.getElementById('restart');
      const pauseBtn = document.getElementById('pause');
      const clearDataBtn = document.getElementById('clearData');
      const muteBtn = document.getElementById('mute');
      const shareBtn = document.getElementById('share');
      const historyListEl = document.getElementById('historyList');
      const codexListEl = document.getElementById('codexList');
      const codexProgressEl = document.getElementById('codexProgress');
      const difficultySelect = document.getElementById('difficulty');
      const skinSelect = document.getElementById('skin');
      const modeSelect = document.getElementById('mode');
      const wrapModeInput = document.getElementById('wrapMode');
      const obstacleModeInput = document.getElementById('obstacleMode');
      const hardcoreModeInput = document.getElementById('hardcoreMode');
      const mobilePad = document.querySelector('.mobile-pad');
      const versionTag = document.getElementById('versionTag');

      const GAME_VERSION = '0.21.0';
      const gridSize = 20;
      const tileCount = canvas.width / gridSize;
      const timedModeDuration = 60;
      const missionOptions = [120, 180, 240, 300];
      const settingsKey = 'snake-settings-v2';
      const statsKey = 'snake-stats-v1';
      const audioKey = 'snake-audio-v1';
      const bestByModeKey = 'snake-best-by-mode-v1';
      const achievementsKey = 'snake-achievements-v1';
      const lastResultKey = 'snake-last-result-v1';
      const historyKey = 'snake-history-v1';
      const codexKey = 'snake-codex-v1';

      const dailyChallengeOptions = [
        { id: 'fast-start', label: 'æé€Ÿçƒ­èº«', speedDelta: -15 },
        { id: 'bonus-rush', label: 'å¤šé‡‘æ¨¡å¼', bonusStep: 30 },
        { id: 'tough-skin', label: 'åšéŸ§æ¨¡å¼', startShield: 1 },
        { id: 'no-rocks', label: 'å‡€ç©ºæ¨¡å¼', noRocks: true }
      ];


      const codexCatalog = [
        { id: 'food', label: 'åŸºç¡€æœ', hint: 'å¸¸è§„é£Ÿç‰©ï¼Œç¨³å®šåŠ åˆ†ã€‚' },
        { id: 'bonus', label: 'å¥–åŠ±æœ', hint: 'çŸ­æ—¶å‡ºç°ï¼Œé«˜é¢åˆ†æ•°ã€‚' },
        { id: 'shield', label: 'æŠ¤ç›¾æœ', hint: 'æä¾›æŠ¤ç›¾ï¼Œå®¹é”™æ›´é«˜ã€‚' },
        { id: 'boost', label: 'å€ç‡æœ', hint: 'çŸ­æ—¶é—´åˆ†æ•° x2ã€‚' },
        { id: 'time', label: 'æ—¶é—´æœ', hint: 'é™æ—¶æ¨¡å¼å¯å»¶é•¿å€’è®¡æ—¶ã€‚' },
        { id: 'freeze', label: 'å†°å†»æœ', hint: 'æš‚æ—¶å‡é€Ÿï¼Œä¾¿äºèµ°ä½ã€‚' },
        { id: 'phase', label: 'ç›¸ä½æœ', hint: 'çŸ­æ—¶é—´ç©¿è¶Šéšœç¢çŸ³ã€‚' }
      ];

      const skinThemes = {
        classic: { board: '#0f1322', head: '#7dffa5', body: '#22c55e', phaseHead: '#d8b4fe', grid: 'rgba(255,255,255,0.07)' },
        neon: { board: '#130f2b', head: '#c084fc', body: '#a855f7', phaseHead: '#67e8f9', grid: 'rgba(255,255,255,0.1)' },
        sunset: { board: '#2a1220', head: '#fb923c', body: '#f97316', phaseHead: '#fdba74', grid: 'rgba(255,255,255,0.08)' },
        pixel: { board: '#0d1b1e', head: '#2dd4bf', body: '#14b8a6', phaseHead: '#93c5fd', grid: 'rgba(255,255,255,0.06)' }
      };

      const dirMap = {
        ArrowUp: { x: 0, y: -1 }, ArrowDown: { x: 0, y: 1 }, ArrowLeft: { x: -1, y: 0 }, ArrowRight: { x: 1, y: 0 },
        w: { x: 0, y: -1 }, s: { x: 0, y: 1 }, a: { x: -1, y: 0 }, d: { x: 1, y: 0 }
      };

      let snake;
      let direction;
      let pendingDirection;
      let food;
      let bonusFood = null;
      let bonusExpireAt = 0;
      let shieldFood = null;
      let shieldExpireAt = 0;
      let boostFood = null;
      let boostExpireAt = 0;
      let timeFood = null;
      let timeExpireAt = 0;
      let freezeFood = null;
      let freezeExpireAt = 0;
      let phaseFood = null;
      let phaseExpireAt = 0;
      let rocks = [];
      let score;
      let bestScore = Number(localStorage.getItem('snake-best') || '0');
      let bestByMode = { classic: 0, timed: 0 };
      let running = false;
      let paused = false;
      let loopTimer;
      let baseSpeed = Number(difficultySelect.value);
      let speed = baseSpeed;
      let touchStart = null;
      let mode = modeSelect.value;
      let remainingTime = timedModeDuration;
      let lastTickMs = 0;
      let combo = 1;
      let lastEatMs = 0;
      let shields = 0;
      let missionTarget = 120;
      let missionAchieved = false;
      let foodsEaten = 0;
      let totalPlays = 0;
      let streakWins = 0;
      let playCountedThisRound = false;
      let countdownTimer = null;
      let muted = false;
      let achievements = { score200: false, combo5: false, timedClear: false };
      let roundMaxCombo = 1;
      let scoreMultiplier = 1;
      let multiplierExpireAt = 0;
      let freezeUntil = 0;
      let phaseUntil = 0;
      let currentChallenge = dailyChallengeOptions[0];
      let lastResult = { score: 0, mode: 'classic', ts: 0 };
      let history = [];
      let discoveredCodex = {};
      let currentSkin = 'classic';

      bestEl.textContent = String(bestScore);
      versionTag.textContent = `v${GAME_VERSION}`;
      versionTag.title = `Snake build ${GAME_VERSION}`;


      function selectDailyChallenge() {
        const dateSeed = Number(new Date().toISOString().slice(0, 10).replaceAll('-', ''));
        currentChallenge = dailyChallengeOptions[dateSeed % dailyChallengeOptions.length];
        challengeEl.textContent = currentChallenge.label;
      }

      function getBonusStep() {
        return currentChallenge.bonusStep || 50;
      }

      function loadSettings() {
        try {
          const parsed = JSON.parse(localStorage.getItem(settingsKey) || '{}');
          if (parsed.mode === 'classic' || parsed.mode === 'timed') modeSelect.value = parsed.mode;
          if (['140', '110', '80'].includes(String(parsed.difficulty))) difficultySelect.value = String(parsed.difficulty);
          if (Object.hasOwn(skinThemes, parsed.skin)) skinSelect.value = parsed.skin;
          wrapModeInput.checked = Boolean(parsed.wrapMode);
          obstacleModeInput.checked = parsed.obstacleMode !== false;
          hardcoreModeInput.checked = Boolean(parsed.hardcoreMode);
        } catch {
          // ignore malformed settings
        }
      }

      function saveSettings() {
        localStorage.setItem(settingsKey, JSON.stringify({
          mode: modeSelect.value,
          difficulty: difficultySelect.value,
          skin: skinSelect.value,
          wrapMode: wrapModeInput.checked,
          obstacleMode: obstacleModeInput.checked,
          hardcoreMode: hardcoreModeInput.checked
        }));
      }








      function defaultCodexState() {
        return Object.fromEntries(codexCatalog.map(item => [item.id, false]));
      }

      function refreshCodex() {
        const discoveredCount = codexCatalog.filter(item => discoveredCodex[item.id]).length;
        codexProgressEl.textContent = `${discoveredCount}/${codexCatalog.length}`;
        codexListEl.innerHTML = codexCatalog.map(item => {
          if (!discoveredCodex[item.id]) return `<li>â“ æœªå‘ç°é“å…·</li>`;
          return `<li>âœ… <strong>${item.label}</strong>ï¼š${item.hint}</li>`;
        }).join('');
      }

      function saveCodex() {
        localStorage.setItem(codexKey, JSON.stringify(discoveredCodex));
      }

      function loadCodex() {
        const base = defaultCodexState();
        try {
          const parsed = JSON.parse(localStorage.getItem(codexKey) || '{}');
          discoveredCodex = { ...base, ...parsed };
        } catch {
          discoveredCodex = base;
        }
        refreshCodex();
      }

      function discoverCodex(id, label) {
        if (discoveredCodex[id]) return;
        discoveredCodex[id] = true;
        saveCodex();
        refreshCodex();
        if (running && !paused) {
          showOverlay(`<p><strong>ğŸ“˜ å›¾é‰´è§£é”</strong></p><p>${label}</p>`);
          setTimeout(() => {
            if (running && !paused) hideOverlay();
          }, 750);
        }
      }

      function loadHistory() {
        try {
          const parsed = JSON.parse(localStorage.getItem(historyKey) || '[]');
          history = Array.isArray(parsed) ? parsed.slice(0, 5) : [];
        } catch {
          history = [];
        }
        renderHistory();
      }

      function saveHistory() {
        localStorage.setItem(historyKey, JSON.stringify(history.slice(0, 5)));
      }

      function addHistoryEntry(score, modeName) {
        history.unshift({ score, mode: modeName, ts: Date.now() });
        history = history.slice(0, 5);
        saveHistory();
        renderHistory();
      }

      function renderHistory() {
        if (!history.length) {
          historyListEl.innerHTML = '<li>æš‚æ— è®°å½•</li>';
          return;
        }
        historyListEl.innerHTML = history
          .map(item => {
            const modeLabel = item.mode === 'timed' ? 'é™æ—¶' : 'ç»å…¸';
            const d = new Date(item.ts || Date.now());
            const hh = String(d.getHours()).padStart(2, '0');
            const mm = String(d.getMinutes()).padStart(2, '0');
            return `<li>${modeLabel}ï¼š${item.score} åˆ† <small>(${hh}:${mm})</small></li>`;
          })
          .join('');
      }

      function loadLastResult() {
        try {
          const parsed = JSON.parse(localStorage.getItem(lastResultKey) || '{}');
          lastResult.score = Number(parsed.score || 0);
          lastResult.mode = parsed.mode === 'timed' ? 'timed' : 'classic';
          lastResult.ts = Number(parsed.ts || 0);
        } catch {
          lastResult = { score: 0, mode: 'classic', ts: 0 };
        }
        refreshLastResultText();
      }

      function saveLastResult() {
        localStorage.setItem(lastResultKey, JSON.stringify(lastResult));
      }

      function refreshLastResultText() {
        if (!lastResult.ts) {
          lastResultEl.textContent = '--';
          return;
        }
        const modeLabel = lastResult.mode === 'timed' ? 'é™æ—¶' : 'ç»å…¸';
        lastResultEl.textContent = `${modeLabel} ${lastResult.score}åˆ†`;
      }

      function loadAchievements() {
        try {
          const parsed = JSON.parse(localStorage.getItem(achievementsKey) || '{}');
          achievements.score200 = Boolean(parsed.score200);
          achievements.combo5 = Boolean(parsed.combo5);
          achievements.timedClear = Boolean(parsed.timedClear);
        } catch {
          achievements = { score200: false, combo5: false, timedClear: false };
        }
        refreshAchievementsText();
      }

      function saveAchievements() {
        localStorage.setItem(achievementsKey, JSON.stringify(achievements));
      }

      function refreshAchievementsText() {
        const count = Number(achievements.score200) + Number(achievements.combo5) + Number(achievements.timedClear);
        achievementsEl.textContent = `${count}/3`;
      }

      function unlockAchievement(key, label) {
        if (achievements[key]) return;
        achievements[key] = true;
        saveAchievements();
        refreshAchievementsText();
        if (running && !paused) {
          showOverlay(`<p><strong>ğŸ† è§£é”æˆå°±</strong></p><p>${label}</p>`);
          setTimeout(() => {
            if (running && !paused) hideOverlay();
          }, 800);
        }
      }

      function loadAudioSetting() {
        muted = localStorage.getItem(audioKey) === '1';
        muteBtn.textContent = muted ? 'ğŸ”‡ éŸ³æ•ˆå…³' : 'ğŸ”Š éŸ³æ•ˆå¼€';
      }

      function saveAudioSetting() {
        localStorage.setItem(audioKey, muted ? '1' : '0');
        muteBtn.textContent = muted ? 'ğŸ”‡ éŸ³æ•ˆå…³' : 'ğŸ”Š éŸ³æ•ˆå¼€';
      }

      function beep(type = 'eat') {
        if (muted) return;
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) return;
        if (!beep.ctx) beep.ctx = new AudioCtx();
        const ctx = beep.ctx;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain); gain.connect(ctx.destination);
        const map = { eat: [620, 0.06], bonus: [820, 0.09], hit: [180, 0.14], mission: [980, 0.12] };
        const [freq, dur] = map[type] || map.eat;
        osc.frequency.value = freq;
        gain.gain.value = 0.0001;
        const t = ctx.currentTime;
        gain.gain.exponentialRampToValueAtTime(0.05, t + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + dur);
        osc.start(t);
        osc.stop(t + dur + 0.01);
      }

      function loadBestByMode() {
        try {
          const parsed = JSON.parse(localStorage.getItem(bestByModeKey) || '{}');
          bestByMode.classic = Number(parsed.classic || 0);
          bestByMode.timed = Number(parsed.timed || 0);
        } catch {
          bestByMode = { classic: 0, timed: 0 };
        }
      }

      function saveBestByMode() {
        localStorage.setItem(bestByModeKey, JSON.stringify(bestByMode));
      }

      function refreshModeBestText() {
        modeBestEl.textContent = String(bestByMode[mode] || 0);
      }

      function loadLifetimeStats() {
        try {
          const parsed = JSON.parse(localStorage.getItem(statsKey) || '{}');
          foodsEaten = Number(parsed.foodsEaten || 0);
          totalPlays = Number(parsed.totalPlays || 0);
          streakWins = Number(parsed.streakWins || 0);
        } catch {
          foodsEaten = 0;
          totalPlays = 0;
          streakWins = 0;
        }
        foodsEl.textContent = String(foodsEaten);
        playsEl.textContent = String(totalPlays);
        streakEl.textContent = String(streakWins);
      }

      function saveLifetimeStats() {
        localStorage.setItem(statsKey, JSON.stringify({ foodsEaten, totalPlays, streakWins }));
      }

      function showOverlay(message) { overlay.innerHTML = `<div>${message}</div>`; overlay.style.display = 'grid'; }
      function hideOverlay() { overlay.style.display = 'none'; }
      function updateTimeText() { timeEl.textContent = mode === 'timed' ? `${Math.max(0, Math.ceil(remainingTime))}s` : '--'; }

      function resetGame(showStartOverlay = true) {
        snake = [{ x: 8, y: 12 }, { x: 7, y: 12 }, { x: 6, y: 12 }];
        direction = { x: 1, y: 0 };
        pendingDirection = direction;
        food = randomFoodPosition();
        bonusFood = null;
        bonusExpireAt = 0;
        shieldFood = null;
        shieldExpireAt = 0;
        boostFood = null;
        boostExpireAt = 0;
        timeFood = null;
        timeExpireAt = 0;
        freezeFood = null;
        freezeExpireAt = 0;
        phaseFood = null;
        phaseExpireAt = 0;
        rocks = [];
        score = 0;
        running = false;
        paused = false;
        remainingTime = timedModeDuration;
        lastTickMs = 0;
        const hardcoreDelta = hardcoreModeInput.checked ? -20 : 0;
        speed = Math.max(45, baseSpeed + (currentChallenge.speedDelta || 0) + hardcoreDelta);
        combo = 1;
        roundMaxCombo = 1;
        lastEatMs = 0;
        shields = hardcoreModeInput.checked ? 0 : (currentChallenge.startShield || 0);
        missionTarget = missionOptions[Math.floor(Math.random() * missionOptions.length)];
        missionAchieved = false;
        playCountedThisRound = false;
        clearInterval(loopTimer);
        clearInterval(countdownTimer);
        pauseBtn.textContent = 'æš‚åœ';
        scoreEl.textContent = '0';
        lengthEl.textContent = String(snake.length);
        comboEl.textContent = 'x1';
        shieldEl.textContent = String(shields);
        missionEl.textContent = `${missionTarget}åˆ†`;
        scoreMultiplier = 1;
        multiplierExpireAt = 0;
        multiplierEl.textContent = 'x1';
        freezeUntil = 0;
        phaseUntil = 0;
        refreshStateText();
        challengeEl.textContent = currentChallenge.label;
        updateTimeText();
        if (showStartOverlay) showOverlay('<p><strong>æŒ‰æ–¹å‘é”®å¼€å§‹æ¸¸æˆ</strong></p><p>W/A/S/Dã€è§¦å±æ–¹å‘é”®æˆ–æ»‘åŠ¨éƒ½å¯æ§åˆ¶</p>');
        draw();
      }

      function isOnSnake(cell) { return snake.some(seg => seg.x === cell.x && seg.y === cell.y); }

      function randomFreeCell() {
        let position;
        do {
          position = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
        } while (
          isOnSnake(position) ||
          (food && food.x === position.x && food.y === position.y) ||
          (bonusFood && bonusFood.x === position.x && bonusFood.y === position.y) ||
          (shieldFood && shieldFood.x === position.x && shieldFood.y === position.y) ||
          (boostFood && boostFood.x === position.x && boostFood.y === position.y) ||
          (timeFood && timeFood.x === position.x && timeFood.y === position.y) ||
          (freezeFood && freezeFood.x === position.x && freezeFood.y === position.y) ||
          (phaseFood && phaseFood.x === position.x && phaseFood.y === position.y) ||
          rocks.some(rock => rock.x === position.x && rock.y === position.y)
        );
        return position;
      }

      function randomFoodPosition() { return randomFreeCell(); }

      function maybeSpawnBonusFood(now) {
        if (bonusFood || score === 0) return;
        if (score % getBonusStep() !== 0) return;
        bonusFood = randomFreeCell();
        bonusExpireAt = now + 3200;
      }

      function maybeSpawnShieldFood(now) {
        if (hardcoreModeInput.checked) return;
        if (shieldFood || shields >= 2) return;
        if (score < 60) return;
        if (score % 70 !== 0) return;
        shieldFood = randomFreeCell();
        shieldExpireAt = now + 4500;
      }


      function maybeSpawnBoostFood(now) {
        if (boostFood || score < 80) return;
        if (score % 90 !== 0) return;
        boostFood = randomFreeCell();
        boostExpireAt = now + 4200;
      }


      function maybeSpawnTimeFood(now) {
        if (timeFood || score < 50) return;
        if (score % 75 !== 0) return;
        timeFood = randomFreeCell();
        timeExpireAt = now + 4600;
      }


      function maybeSpawnFreezeFood(now) {
        if (freezeFood || score < 40) return;
        if (score % 65 !== 0) return;
        freezeFood = randomFreeCell();
        freezeExpireAt = now + 4200;
      }

      function maybeSpawnPhaseFood(now) {
        if (phaseFood || score < 70) return;
        if (score % 85 !== 0) return;
        phaseFood = randomFreeCell();
        phaseExpireAt = now + 4500;
      }

      function effectiveSpeed() {
        const slowed = performance.now() < freezeUntil;
        return speed + (slowed ? 40 : 0);
      }

      function refreshStateText(now = performance.now()) {
        const states = [];
        if (now < freezeUntil) states.push('å‡é€Ÿ');
        if (now < phaseUntil) states.push('ç›¸ä½');
        stateEl.textContent = states.join('+') || 'æ­£å¸¸';
      }

      function maybeAddRock() {
        if (!obstacleModeInput.checked || currentChallenge.noRocks) return;
        if (score < 80) return;
        if (score % 40 !== 0) return;
        if (rocks.length >= 8) return;
        rocks.push(randomFreeCell());
      }

      function startLoop() {
        clearInterval(loopTimer);
        clearInterval(countdownTimer);
        lastTickMs = performance.now();
        loopTimer = setInterval(update, effectiveSpeed());
      }

      function startGameIfNeeded() {
        if (running && !paused) return;
        if (!running) {
          running = true;
          paused = false;
          if (!playCountedThisRound) {
            totalPlays += 1;
            playsEl.textContent = String(totalPlays);
            saveLifetimeStats();
            playCountedThisRound = true;
          }
          pauseBtn.textContent = 'æš‚åœ';
          startCountdown(() => {
            if (paused || !running) return;
            hideOverlay();
            startLoop();
          });
          return;
        }
        if (paused) {
          paused = false;
          hideOverlay();
          pauseBtn.textContent = 'æš‚åœ';
          startLoop();
        }
      }


      function startCountdown(onDone) {
        clearInterval(countdownTimer);
        let count = 3;
        showOverlay(`<p><strong>${count}</strong></p><p>å‡†å¤‡å¼€å§‹</p>`);
        countdownTimer = setInterval(() => {
          if (paused || !running) {
            clearInterval(countdownTimer);
            return;
          }
          count -= 1;
          if (count <= 0) {
            clearInterval(countdownTimer);
            onDone();
            return;
          }
          showOverlay(`<p><strong>${count}</strong></p><p>å‡†å¤‡å¼€å§‹</p>`);
        }, 550);
      }

      function changeDirection(next) {
        const isReverse = next.x === -direction.x && next.y === -direction.y;
        if (!isReverse) pendingDirection = next;
        startGameIfNeeded();
      }

      function togglePause() {
        if (!running) return;
        if (paused) return startGameIfNeeded();
        paused = true;
        clearInterval(loopTimer);
        clearInterval(countdownTimer);
        pauseBtn.textContent = 'ç»§ç»­';
        showOverlay('<p><strong>å·²æš‚åœ</strong></p><p>æŒ‰ç©ºæ ¼ / P æˆ–â€œç»§ç»­â€æ¢å¤æ¸¸æˆ</p>');
      }

      function isCollision(head) {
        const inPhase = performance.now() < phaseUntil;
        const hitWall = !wrapModeInput.checked && (head.x < 0 || head.y < 0 || head.x >= tileCount || head.y >= tileCount);
        const hitSelf = snake.some(seg => seg.x === head.x && seg.y === head.y);
        const hitRock = !inPhase && rocks.some(rock => rock.x === head.x && rock.y === head.y);
        return hitWall || hitSelf || hitRock;
      }

      function endGame(reasonText) {
        clearInterval(loopTimer);
        clearInterval(countdownTimer);
        running = false;
        paused = false;

        if (mode === 'timed' && reasonText.includes('æ—¶é—´åˆ°')) {
          streakWins += 1;
        } else {
          streakWins = 0;
        }
        streakEl.textContent = String(streakWins);
        saveLifetimeStats();

        if (score > bestScore) {
          bestScore = score;
          bestEl.textContent = String(bestScore);
          localStorage.setItem('snake-best', String(bestScore));
        }

        if (score > (bestByMode[mode] || 0)) {
          bestByMode[mode] = score;
          saveBestByMode();
          refreshModeBestText();
        }

        lastResult = { score, mode, ts: Date.now() };
        saveLastResult();
        refreshLastResultText();
        addHistoryEntry(score, mode);

        if (score >= 200) unlockAchievement('score200', 'é«˜åˆ†è¾¾äººï¼ˆå•å±€ 200 åˆ†ï¼‰');
        if (roundMaxCombo >= 5) unlockAchievement('combo5', 'è¿å‡»é«˜æ‰‹ï¼ˆè¿å‡»è¾¾åˆ° x5ï¼‰');
        if (mode === 'timed' && reasonText.includes('æ—¶é—´åˆ°') && score >= 120) unlockAchievement('timedClear', 'é™æ—¶æŒ‘æˆ˜è€…ï¼ˆé™æ—¶æ¨¡å¼ 120+ï¼‰');

        beep('hit');
        showOverlay(`<p><strong>${reasonText}</strong></p><p>æœ€ç»ˆå¾—åˆ† ${score}</p><p>æŒ‰æ–¹å‘é”®æˆ–ç‚¹å‡»â€œé‡æ–°å¼€å§‹â€å†æ¥ä¸€å±€</p>`);
      }

      function update() {
        const now = performance.now();
        const elapsed = lastTickMs ? (now - lastTickMs) / 1000 : 0;
        lastTickMs = now;

        if (mode === 'timed') {
          remainingTime -= elapsed;
          updateTimeText();
          if (remainingTime <= 0) return endGame('â° æ—¶é—´åˆ°ï¼');
        }

        if (bonusFood && now > bonusExpireAt) bonusFood = null;
        if (shieldFood && now > shieldExpireAt) shieldFood = null;
        if (boostFood && now > boostExpireAt) boostFood = null;
        if (timeFood && now > timeExpireAt) timeFood = null;
        if (freezeFood && now > freezeExpireAt) freezeFood = null;
        if (phaseFood && now > phaseExpireAt) phaseFood = null;
        if (scoreMultiplier > 1 && now > multiplierExpireAt) {
          scoreMultiplier = 1;
          multiplierEl.textContent = 'x1';
        }
        if (now > freezeUntil) freezeUntil = 0;
        if (now > phaseUntil) phaseUntil = 0;
        refreshStateText(now);

        direction = pendingDirection;
        const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

        if (wrapModeInput.checked) {
          if (head.x < 0) head.x = tileCount - 1;
          if (head.x >= tileCount) head.x = 0;
          if (head.y < 0) head.y = tileCount - 1;
          if (head.y >= tileCount) head.y = 0;
        }

        if (isCollision(head)) {
          if (!hardcoreModeInput.checked && shields > 0) {
            shields -= 1;
            shieldEl.textContent = String(shields);
          } else {
            return endGame('ğŸ’¥ æ’åˆ°äº†ï¼');
          }
        }

        snake.unshift(head);

        let ate = false;
        if (head.x === food.x && head.y === food.y) {
          ate = true;
          score += 10 * scoreMultiplier;
          foodsEaten += 1;
          foodsEl.textContent = String(foodsEaten);
          saveLifetimeStats();
          food = randomFoodPosition();
          maybeSpawnBonusFood(now);
          maybeSpawnShieldFood(now);
          maybeSpawnBoostFood(now);
          maybeSpawnTimeFood(now);
          maybeSpawnFreezeFood(now);
          maybeSpawnPhaseFood(now);
          discoverCodex('food', 'åŸºç¡€æœ');
          beep('eat');
        }

        if (bonusFood && head.x === bonusFood.x && head.y === bonusFood.y) {
          ate = true;
          score += 30 * scoreMultiplier;
          foodsEaten += 1;
          foodsEl.textContent = String(foodsEaten);
          saveLifetimeStats();
          bonusFood = null;
          discoverCodex('bonus', 'å¥–åŠ±æœ');
          beep('bonus');
        }

        if (shieldFood && head.x === shieldFood.x && head.y === shieldFood.y) {
          ate = true;
          if (!hardcoreModeInput.checked) {
            shields = Math.min(2, shields + 1);
            shieldEl.textContent = String(shields);
          }
          shieldFood = null;
          discoverCodex('shield', 'æŠ¤ç›¾æœ');
          beep('bonus');
        }

        if (boostFood && head.x === boostFood.x && head.y === boostFood.y) {
          ate = true;
          scoreMultiplier = 2;
          multiplierExpireAt = now + 8000;
          multiplierEl.textContent = 'x2';
          boostFood = null;
          discoverCodex('boost', 'å€ç‡æœ');
          beep('mission');
        }

        if (timeFood && head.x === timeFood.x && head.y === timeFood.y) {
          ate = true;
          if (mode === 'timed') {
            remainingTime += 5;
            updateTimeText();
          } else {
            score += 15 * scoreMultiplier;
          }
          timeFood = null;
          discoverCodex('time', 'æ—¶é—´æœ');
          beep('bonus');
        }

        if (freezeFood && head.x === freezeFood.x && head.y === freezeFood.y) {
          ate = true;
          freezeUntil = now + 6000;
          freezeFood = null;
          refreshStateText(now);
          discoverCodex('freeze', 'å†°å†»æœ');
          beep('mission');
          if (running && !paused) {
            startLoop();
          }
        }

        if (phaseFood && head.x === phaseFood.x && head.y === phaseFood.y) {
          ate = true;
          phaseUntil = now + 6000;
          phaseFood = null;
          refreshStateText(now);
          discoverCodex('phase', 'ç›¸ä½æœ');
          beep('mission');
        }

        if (ate) {
          const eatDelta = lastEatMs ? now - lastEatMs : Infinity;
          const comboWindow = hardcoreModeInput.checked ? 2000 : 3000;
          combo = eatDelta <= comboWindow ? Math.min(combo + 1, 9) : 1;
          roundMaxCombo = Math.max(roundMaxCombo, combo);
          score += (combo - 1) * 2 * scoreMultiplier;
          comboEl.textContent = `x${combo}`;
          lastEatMs = now;
          maybeAddRock();
        } else if (lastEatMs && now - lastEatMs > (hardcoreModeInput.checked ? 2000 : 3000)) {
          combo = 1;
          comboEl.textContent = 'x1';
        }

        if (!ate) {
          snake.pop();
        } else {
          const speedBoost = Math.floor(score / 50) * 5;
          const hardcoreDelta2 = hardcoreModeInput.checked ? -20 : 0;
          speed = Math.max(45, baseSpeed + hardcoreDelta2 - speedBoost);
          if (running && !paused) startLoop();
        }

        scoreEl.textContent = String(score);
        lengthEl.textContent = String(snake.length);

        if (!missionAchieved && score >= missionTarget) {
          missionAchieved = true;
          if (!hardcoreModeInput.checked) {
            shields = Math.min(2, shields + 1);
            shieldEl.textContent = String(shields);
          }
          missionEl.textContent = `å®Œæˆâœ”`;
          if (running && !paused) {
            beep('mission');
            const rewardText = hardcoreModeInput.checked ? 'ç¡¬æ ¸æ¨¡å¼ï¼šæ— æŠ¤ç›¾å¥–åŠ±' : 'å¥–åŠ±ï¼šæŠ¤ç›¾ +1';
            showOverlay(`<p><strong>ä»»åŠ¡è¾¾æˆï¼</strong></p><p>${rewardText}</p>`);
            setTimeout(() => {
              if (running && !paused) hideOverlay();
            }, 700);
          }
        }

        draw();
      }

      function drawGrid() {
        ctx.strokeStyle = skinThemes[currentSkin].grid;
        ctx.lineWidth = 1;
        for (let i = 0; i <= tileCount; i++) {
          const line = i * gridSize;
          ctx.beginPath(); ctx.moveTo(line, 0); ctx.lineTo(line, canvas.height); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0, line); ctx.lineTo(canvas.width, line); ctx.stroke();
        }
      }

      function drawCell({ x, y }, color, radius = 4) {
        const px = x * gridSize;
        const py = y * gridSize;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(px + 1, py + 1, gridSize - 2, gridSize - 2, radius);
        ctx.fill();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = skinThemes[currentSkin].board;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawCell(food, '#f472b6', 6);
        if (bonusFood) drawCell(bonusFood, '#facc15', 8);
        if (shieldFood) drawCell(shieldFood, '#38bdf8', 8);
        if (boostFood) drawCell(boostFood, '#f59e0b', 8);
        if (timeFood) drawCell(timeFood, '#a78bfa', 8);
        if (freezeFood) drawCell(freezeFood, '#22d3ee', 8);
        if (phaseFood) drawCell(phaseFood, '#c084fc', 8);
        rocks.forEach(rock => drawCell(rock, '#64748b', 5));
        const headColor = performance.now() < phaseUntil ? skinThemes[currentSkin].phaseHead : skinThemes[currentSkin].head;
        snake.forEach((segment, index) => drawCell(segment, index === 0 ? headColor : skinThemes[currentSkin].body));
      }

      document.addEventListener('keydown', (event) => {
        if (event.code === 'Space' || event.key.toLowerCase() === 'p') {
          event.preventDefault();
          togglePause();
          return;
        }
        const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
        const next = dirMap[key];
        if (!next) return;
        event.preventDefault();
        changeDirection(next);
      });

      mobilePad.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-dir]');
        if (!button) return;
        changeDirection(dirMap[button.dataset.dir]);
      });

      canvas.addEventListener('touchstart', (event) => {
        const touch = event.changedTouches[0];
        touchStart = { x: touch.clientX, y: touch.clientY };
      }, { passive: true });

      canvas.addEventListener('touchend', (event) => {
        if (!touchStart) return;
        const touch = event.changedTouches[0];
        const dx = touch.clientX - touchStart.x;
        const dy = touch.clientY - touchStart.y;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);
        if (absX < 18 && absY < 18) { touchStart = null; return; }
        if (absX > absY) changeDirection(dx > 0 ? dirMap.ArrowRight : dirMap.ArrowLeft);
        else changeDirection(dy > 0 ? dirMap.ArrowDown : dirMap.ArrowUp);
        touchStart = null;
      }, { passive: true });

      restartBtn.addEventListener('click', () => resetGame(true));
      pauseBtn.addEventListener('click', togglePause);

      difficultySelect.addEventListener('change', () => {
        saveSettings();
        baseSpeed = Number(difficultySelect.value);
        const speedBoost = Math.floor(score / 50) * 5;
        const hardcoreDelta3 = hardcoreModeInput.checked ? -20 : 0;
        speed = Math.max(45, baseSpeed + hardcoreDelta3 - speedBoost);
        if (running && !paused) startLoop();
      });

      modeSelect.addEventListener('change', () => {
        saveSettings();
        mode = modeSelect.value;
        refreshModeBestText();
        resetGame(true);
      });

      obstacleModeInput.addEventListener('change', () => { saveSettings(); resetGame(true); });
      hardcoreModeInput.addEventListener('change', () => { saveSettings(); resetGame(true); });
      wrapModeInput.addEventListener('change', saveSettings);
      skinSelect.addEventListener('change', () => {
        saveSettings();
        currentSkin = skinSelect.value;
        draw();
      });


      document.addEventListener('visibilitychange', () => {
        if (document.hidden && running && !paused) {
          togglePause();
        }
      });


      clearDataBtn.addEventListener('click', () => {
        localStorage.removeItem('snake-best');
        localStorage.removeItem(settingsKey);
        localStorage.removeItem(statsKey);
        localStorage.removeItem(bestByModeKey);
        localStorage.removeItem(audioKey);
        localStorage.removeItem(achievementsKey);
        localStorage.removeItem(lastResultKey);
        localStorage.removeItem(historyKey);
        localStorage.removeItem(codexKey);
        bestScore = 0;
        bestEl.textContent = '0';
        bestByMode = { classic: 0, timed: 0 };
        refreshModeBestText();
        foodsEaten = 0;
        totalPlays = 0;
        streakWins = 0;
        muted = false;
        saveAudioSetting();
        foodsEl.textContent = '0';
        playsEl.textContent = '0';
        streakEl.textContent = '0';
        achievements = { score200: false, combo5: false, timedClear: false };
        refreshAchievementsText();
        lastResult = { score: 0, mode: 'classic', ts: 0 };
        refreshLastResultText();
        history = [];
        renderHistory();
        discoveredCodex = defaultCodexState();
        refreshCodex();
        resetGame(true);
      });


      shareBtn.addEventListener('click', async () => {
        const modeLabel = mode === 'timed' ? 'é™æ—¶æ¨¡å¼' : 'ç»å…¸æ¨¡å¼';
        const hardcoreTag = hardcoreModeInput.checked ? 'ï¼ˆç¡¬æ ¸ï¼‰' : '';
        const text = `æˆ‘åœ¨è´ªåƒè›‡ v${GAME_VERSION} çš„${modeLabel}${hardcoreTag}æ‹¿åˆ° ${score} åˆ†ï¼æŒ‘æˆ˜ï¼š${currentChallenge.label}ï¼Œæœ€é«˜å€ç‡${multiplierEl.textContent}ï¼Œå½“å‰çŠ¶æ€${stateEl.textContent}`;
        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(text);
            showOverlay('<p><strong>å·²å¤åˆ¶æˆ˜ç»©</strong></p><p>å¿«å»åˆ†äº«ç»™å¥½å‹å§</p>');
            setTimeout(() => { if (running && !paused) hideOverlay(); }, 700);
          }
        } catch {
          showOverlay('<p><strong>å¤åˆ¶å¤±è´¥</strong></p><p>å½“å‰æµè§ˆå™¨ä¸æ”¯æŒå‰ªè´´æ¿</p>');
          setTimeout(() => { if (running && !paused) hideOverlay(); }, 900);
        }
      });

      muteBtn.addEventListener('click', () => {
        muted = !muted;
        saveAudioSetting();
      });

      selectDailyChallenge();
      loadLifetimeStats();
      loadHistory();
      loadCodex();
      loadLastResult();
      loadAchievements();
      loadAudioSetting();
      loadBestByMode();
      loadSettings();
      currentSkin = skinSelect.value;
      mode = modeSelect.value;
      baseSpeed = Number(difficultySelect.value);
      refreshModeBestText();
      resetGame(true);
    </script>

    <!--
      snake-feature-evolver merged notes (from removed markdown files):

      Scope
      - Primary target: index.html (single-file app).
      - Keep changes compatible with existing localStorage keys unless explicitly migrating.

      Workflow
      1) Read current state quickly: mode, power-ups, persistence, controls, version.
      2) Implement one coherent feature slice (pickup/modifier, toggle, progression).
      3) Version discipline: bump visible versionTag and GAME_VERSION together (semver).
      4) Persistence updates: add dedicated key when needed; clearData must reset it.
      5) Validation: JS parse check, git diff --check, and screenshot if visual UI changed.
      6) Keep changes focused and summarize gameplay/storage impact.

      Architecture landmarks (index.html)
      - CSS/layout + HUD stats
      - Controls row (restart/pause/toggles)
      - Canvas + overlay
      - Inline JS game engine

      Integration checklist for new mechanics
      - Add state variables
      - Add spawn/expire handling in update
      - Add pickup collision handling in update
      - Add rendering in draw
      - Add HUD indicator if user-visible
      - Add persistence + clear/reset handling if needed

      Quick checks
      - node -e "const fs=require('fs');const m=fs.readFileSync('index.html','utf8').match(/<script>([\s\S]*)<\/script>/);new Function(m[1]);console.log('js ok')"
      - git diff --check
      - git ls-files | rg '__pycache__|\.pyc$|\.png$|\.jpg$|\.jpeg$|\.gif$|\.webp$' && echo 'binary-like tracked file found' && exit 1 || true
    -->

  </body>
</html>

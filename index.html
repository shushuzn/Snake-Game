<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è´ªåƒè›‡æ¸¸æˆ</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        background: radial-gradient(circle at top, #1a1a2e, #0b0b16 50%, #05050d);
        color: #f5f5f5;
        min-height: 100vh;
        display: grid;
        place-items: center;
        padding: 12px;
      }
      .game-shell {
        width: min(92vw, 560px);
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 16px;
        backdrop-filter: blur(6px);
        box-shadow: 0 20px 45px rgba(0, 0, 0, 0.4);
      }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        gap: 12px;
      }
      .header h1 {
        margin: 0;
        font-size: 1.4rem;
      }
      .stats {
        display: flex;
        gap: 12px;
        font-size: 0.9rem;
        flex-wrap: wrap;
        justify-content: end;
      }
      .stats b {
        color: #7dffa5;
      }
      .stats b.warn {
        color: #fbbf24;
      }
      #board {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 12px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        background: #0f1322;
        display: block;
      }
      .controls-row {
        margin-top: 12px;
        display: flex;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      .controls-group {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      button,
      select {
        border: 0;
        border-radius: 10px;
        font-weight: 700;
      }
      button {
        background: linear-gradient(135deg, #34d399, #10b981);
        color: #052014;
        padding: 9px 14px;
        cursor: pointer;
      }
      button.secondary {
        background: linear-gradient(135deg, #93c5fd, #60a5fa);
        color: #081426;
      }
      .label-inline {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 0.88rem;
      }
      .label-inline input {
        accent-color: #34d399;
      }
      select {
        background: #1e293b;
        color: #f8fafc;
        padding: 7px 10px;
        border: 1px solid rgba(255, 255, 255, 0.18);
      }
      .tips {
        margin-top: 10px;
        color: #d3d3e7;
        font-size: 0.88rem;
      }
      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        text-align: center;
        padding: 12px;
        color: #fff;
        pointer-events: none;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      }
      .board-wrap {
        position: relative;
      }
      .overlay p {
        margin: 4px 0;
      }
      .mobile-pad {
        margin: 14px auto 2px;
        width: 170px;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 6px;
        user-select: none;
      }
      .mobile-pad button {
        padding: 10px 0;
        border-radius: 8px;
        font-size: 18px;
      }
      .mobile-pad .empty {
        visibility: hidden;
      }
      @media (min-width: 700px) {
        .mobile-pad {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <main class="game-shell">
      <section class="header">
        <h1>ğŸ è´ªåƒè›‡</h1>
        <div class="stats">
          <span>åˆ†æ•°ï¼š<b id="score">0</b></span>
          <span>æœ€é«˜åˆ†ï¼š<b id="best">0</b></span>
          <span>é•¿åº¦ï¼š<b id="length">3</b></span>
          <span>æ—¶é—´ï¼š<b id="time" class="warn">--</b></span>
        </div>
      </section>

      <div class="board-wrap">
        <canvas id="board" width="500" height="500" aria-label="è´ªåƒè›‡æ£‹ç›˜"></canvas>
        <div class="overlay" id="overlay">
          <div>
            <p><strong>æŒ‰æ–¹å‘é”®å¼€å§‹æ¸¸æˆ</strong></p>
            <p>W/A/S/Dã€è§¦å±æ–¹å‘é”®æˆ–æ»‘åŠ¨éƒ½å¯æ§åˆ¶</p>
          </div>
        </div>
      </div>

      <section class="controls-row">
        <div class="controls-group">
          <button id="restart" type="button">é‡æ–°å¼€å§‹</button>
          <button id="pause" type="button" class="secondary">æš‚åœ</button>
        </div>
        <div class="controls-group">
          <label class="label-inline" for="mode">
            æ¨¡å¼ï¼š
            <select id="mode">
              <option value="classic" selected>ç»å…¸</option>
              <option value="timed">é™æ—¶ 60 ç§’</option>
            </select>
          </label>
          <label class="label-inline" for="difficulty">
            éš¾åº¦ï¼š
            <select id="difficulty">
              <option value="140">æ‚ é—²</option>
              <option value="110" selected>æ ‡å‡†</option>
              <option value="80">æé€Ÿ</option>
            </select>
          </label>
          <label class="label-inline" for="wrapMode">
            <input id="wrapMode" type="checkbox" />
            ç©¿å¢™
          </label>
        </div>
      </section>

      <p class="tips">æç¤ºï¼šç©ºæ ¼æš‚åœ/ç»§ç»­ã€‚é‡‘è‰²é£Ÿç‰©æ˜¯é™æ—¶å¥–åŠ±ï¼ˆ+30 åˆ†ï¼‰ã€‚æ™®é€šæ¨¡å¼æ’å¢™ä¼šå¤±è´¥ã€‚</p>

      <div class="mobile-pad" aria-label="ç§»åŠ¨æ§åˆ¶">
        <button class="empty" tabindex="-1"></button>
        <button data-dir="ArrowUp" aria-label="ä¸Š">â¬†ï¸</button>
        <button class="empty" tabindex="-1"></button>
        <button data-dir="ArrowLeft" aria-label="å·¦">â¬…ï¸</button>
        <button data-dir="ArrowDown" aria-label="ä¸‹">â¬‡ï¸</button>
        <button data-dir="ArrowRight" aria-label="å³">â¡ï¸</button>
      </div>
    </main>

    <script>
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const lengthEl = document.getElementById('length');
      const timeEl = document.getElementById('time');
      const overlay = document.getElementById('overlay');
      const restartBtn = document.getElementById('restart');
      const pauseBtn = document.getElementById('pause');
      const difficultySelect = document.getElementById('difficulty');
      const modeSelect = document.getElementById('mode');
      const wrapModeInput = document.getElementById('wrapMode');
      const mobilePad = document.querySelector('.mobile-pad');

      const gridSize = 20;
      const tileCount = canvas.width / gridSize;
      const timedModeDuration = 60;

      const dirMap = {
        ArrowUp: { x: 0, y: -1 },
        ArrowDown: { x: 0, y: 1 },
        ArrowLeft: { x: -1, y: 0 },
        ArrowRight: { x: 1, y: 0 },
        w: { x: 0, y: -1 },
        s: { x: 0, y: 1 },
        a: { x: -1, y: 0 },
        d: { x: 1, y: 0 }
      };

      let snake;
      let direction;
      let pendingDirection;
      let food;
      let bonusFood = null;
      let bonusExpireAt = 0;
      let score;
      let bestScore = Number(localStorage.getItem('snake-best') || '0');
      let running = false;
      let paused = false;
      let loopTimer;
      let baseSpeed = Number(difficultySelect.value);
      let speed = baseSpeed;
      let touchStart = null;
      let mode = modeSelect.value;
      let remainingTime = timedModeDuration;
      let lastTickMs = 0;

      bestEl.textContent = String(bestScore);

      function showOverlay(message) {
        overlay.innerHTML = `<div>${message}</div>`;
        overlay.style.display = 'grid';
      }

      function hideOverlay() {
        overlay.style.display = 'none';
      }

      function updateTimeText() {
        timeEl.textContent = mode === 'timed' ? `${Math.max(0, Math.ceil(remainingTime))}s` : '--';
      }

      function resetGame(showStartOverlay = true) {
        snake = [
          { x: 8, y: 12 },
          { x: 7, y: 12 },
          { x: 6, y: 12 }
        ];
        direction = { x: 1, y: 0 };
        pendingDirection = direction;
        food = randomFoodPosition();
        bonusFood = null;
        bonusExpireAt = 0;
        score = 0;
        running = false;
        paused = false;
        remainingTime = timedModeDuration;
        lastTickMs = 0;
        speed = baseSpeed;
        clearInterval(loopTimer);
        pauseBtn.textContent = 'æš‚åœ';
        scoreEl.textContent = '0';
        lengthEl.textContent = String(snake.length);
        updateTimeText();
        if (showStartOverlay) {
          showOverlay('<p><strong>æŒ‰æ–¹å‘é”®å¼€å§‹æ¸¸æˆ</strong></p><p>W/A/S/Dã€è§¦å±æ–¹å‘é”®æˆ–æ»‘åŠ¨éƒ½å¯æ§åˆ¶</p>');
        }
        draw();
      }

      function isOnSnake(cell) {
        return snake.some(seg => seg.x === cell.x && seg.y === cell.y);
      }

      function randomFreeCell() {
        let position;
        do {
          position = {
            x: Math.floor(Math.random() * tileCount),
            y: Math.floor(Math.random() * tileCount)
          };
        } while (
          isOnSnake(position) ||
          (food && food.x === position.x && food.y === position.y) ||
          (bonusFood && bonusFood.x === position.x && bonusFood.y === position.y)
        );
        return position;
      }

      function randomFoodPosition() {
        return randomFreeCell();
      }

      function maybeSpawnBonusFood(now) {
        if (bonusFood || score === 0) return;
        if (score % 50 !== 0) return;
        bonusFood = randomFreeCell();
        bonusExpireAt = now + 3200;
      }

      function startLoop() {
        clearInterval(loopTimer);
        lastTickMs = performance.now();
        loopTimer = setInterval(update, speed);
      }

      function startGameIfNeeded() {
        if (running && !paused) return;
        if (!running) {
          running = true;
          paused = false;
          hideOverlay();
          pauseBtn.textContent = 'æš‚åœ';
          startLoop();
          return;
        }
        if (paused) {
          paused = false;
          hideOverlay();
          pauseBtn.textContent = 'æš‚åœ';
          startLoop();
        }
      }

      function changeDirection(next) {
        const isReverse = next.x === -direction.x && next.y === -direction.y;
        if (!isReverse) {
          pendingDirection = next;
        }
        startGameIfNeeded();
      }

      function togglePause() {
        if (!running) return;
        if (paused) {
          startGameIfNeeded();
          return;
        }
        paused = true;
        clearInterval(loopTimer);
        pauseBtn.textContent = 'ç»§ç»­';
        showOverlay('<p><strong>å·²æš‚åœ</strong></p><p>æŒ‰ç©ºæ ¼æˆ–â€œç»§ç»­â€æ¢å¤æ¸¸æˆ</p>');
      }

      function update() {
        const now = performance.now();
        const elapsed = lastTickMs ? (now - lastTickMs) / 1000 : 0;
        lastTickMs = now;

        if (mode === 'timed') {
          remainingTime -= elapsed;
          updateTimeText();
          if (remainingTime <= 0) {
            endGame('â° æ—¶é—´åˆ°ï¼');
            return;
          }
        }

        if (bonusFood && now > bonusExpireAt) {
          bonusFood = null;
        }

        direction = pendingDirection;
        const head = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y
        };

        if (wrapModeInput.checked) {
          if (head.x < 0) head.x = tileCount - 1;
          if (head.x >= tileCount) head.x = 0;
          if (head.y < 0) head.y = tileCount - 1;
          if (head.y >= tileCount) head.y = 0;
        }

        if (isCollision(head)) {
          endGame('ğŸ’¥ æ’åˆ°äº†ï¼');
          return;
        }

        snake.unshift(head);

        let ate = false;
        if (head.x === food.x && head.y === food.y) {
          ate = true;
          score += 10;
          food = randomFoodPosition();
          maybeSpawnBonusFood(now);
        }

        if (bonusFood && head.x === bonusFood.x && head.y === bonusFood.y) {
          ate = true;
          score += 30;
          bonusFood = null;
        }

        if (!ate) {
          snake.pop();
        } else {
          const speedBoost = Math.floor(score / 50) * 5;
          speed = Math.max(55, baseSpeed - speedBoost);
          if (running && !paused) {
            startLoop();
          }
        }

        scoreEl.textContent = String(score);
        lengthEl.textContent = String(snake.length);
        draw();
      }

      function isCollision(head) {
        const hitWall = !wrapModeInput.checked && (head.x < 0 || head.y < 0 || head.x >= tileCount || head.y >= tileCount);
        const hitSelf = snake.some(seg => seg.x === head.x && seg.y === head.y);
        return hitWall || hitSelf;
      }

      function endGame(reasonText) {
        clearInterval(loopTimer);
        running = false;
        paused = false;

        if (score > bestScore) {
          bestScore = score;
          bestEl.textContent = String(bestScore);
          localStorage.setItem('snake-best', String(bestScore));
        }

        showOverlay(`<p><strong>${reasonText}</strong></p><p>æœ€ç»ˆå¾—åˆ† ${score}</p><p>æŒ‰æ–¹å‘é”®æˆ–ç‚¹å‡»â€œé‡æ–°å¼€å§‹â€å†æ¥ä¸€å±€</p>`);
      }

      function drawGrid() {
        ctx.strokeStyle = 'rgba(255,255,255,0.07)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= tileCount; i++) {
          const line = i * gridSize;
          ctx.beginPath();
          ctx.moveTo(line, 0);
          ctx.lineTo(line, canvas.height);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, line);
          ctx.lineTo(canvas.width, line);
          ctx.stroke();
        }
      }

      function drawCell({ x, y }, color, radius = 4) {
        const px = x * gridSize;
        const py = y * gridSize;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(px + 1, py + 1, gridSize - 2, gridSize - 2, radius);
        ctx.fill();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawCell(food, '#f472b6', 6);
        if (bonusFood) {
          drawCell(bonusFood, '#facc15', 8);
        }
        snake.forEach((segment, index) => {
          drawCell(segment, index === 0 ? '#7dffa5' : '#22c55e');
        });
      }

      document.addEventListener('keydown', (event) => {
        if (event.code === 'Space') {
          event.preventDefault();
          togglePause();
          return;
        }

        const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
        const next = dirMap[key];
        if (!next) return;

        event.preventDefault();
        changeDirection(next);
      });

      mobilePad.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-dir]');
        if (!button) return;
        const next = dirMap[button.dataset.dir];
        changeDirection(next);
      });

      canvas.addEventListener('touchstart', (event) => {
        const touch = event.changedTouches[0];
        touchStart = { x: touch.clientX, y: touch.clientY };
      }, { passive: true });

      canvas.addEventListener('touchend', (event) => {
        if (!touchStart) return;
        const touch = event.changedTouches[0];
        const dx = touch.clientX - touchStart.x;
        const dy = touch.clientY - touchStart.y;
        const absX = Math.abs(dx);
        const absY = Math.abs(dy);

        if (absX < 18 && absY < 18) {
          touchStart = null;
          return;
        }

        if (absX > absY) {
          changeDirection(dx > 0 ? dirMap.ArrowRight : dirMap.ArrowLeft);
        } else {
          changeDirection(dy > 0 ? dirMap.ArrowDown : dirMap.ArrowUp);
        }

        touchStart = null;
      }, { passive: true });

      restartBtn.addEventListener('click', () => resetGame(true));
      pauseBtn.addEventListener('click', togglePause);

      difficultySelect.addEventListener('change', () => {
        baseSpeed = Number(difficultySelect.value);
        const speedBoost = Math.floor(score / 50) * 5;
        speed = Math.max(55, baseSpeed - speedBoost);
        if (running && !paused) {
          startLoop();
        }
      });

      modeSelect.addEventListener('change', () => {
        mode = modeSelect.value;
        resetGame(true);
      });

      resetGame(true);
    </script>
  </body>
</html>

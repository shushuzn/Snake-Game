<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è´ªåƒè›‡æ¸¸æˆ</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        background: radial-gradient(circle at top, #1a1a2e, #0b0b16 50%, #05050d);
        color: #f5f5f5;
        min-height: 100vh;
        display: grid;
        place-items: center;
      }
      .game-shell {
        width: min(92vw, 560px);
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 16px;
        padding: 16px;
        backdrop-filter: blur(6px);
        box-shadow: 0 20px 45px rgba(0, 0, 0, 0.4);
      }
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }
      .stats {
        display: flex;
        gap: 14px;
        font-size: 0.95rem;
      }
      .stats b {
        color: #7dffa5;
      }
      #board {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 12px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        background: #0f1322;
        display: block;
      }
      .actions {
        margin-top: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      button {
        border: 0;
        border-radius: 10px;
        background: linear-gradient(135deg, #34d399, #10b981);
        color: #052014;
        font-weight: 700;
        padding: 9px 14px;
        cursor: pointer;
      }
      .tips {
        color: #d3d3e7;
        font-size: 0.9rem;
      }
      .overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        text-align: center;
        padding: 12px;
        color: #fff;
        pointer-events: none;
      }
      .board-wrap {
        position: relative;
      }
      .overlay p {
        margin: 4px 0;
      }
    </style>
  </head>
  <body>
    <main class="game-shell">
      <section class="header">
        <h1>ğŸ è´ªåƒè›‡</h1>
        <div class="stats">
          <span>åˆ†æ•°ï¼š<b id="score">0</b></span>
          <span>æœ€é«˜åˆ†ï¼š<b id="best">0</b></span>
        </div>
      </section>

      <div class="board-wrap">
        <canvas id="board" width="500" height="500" aria-label="è´ªåƒè›‡æ£‹ç›˜"></canvas>
        <div class="overlay" id="overlay">
          <div>
            <p><strong>æŒ‰æ–¹å‘é”®å¼€å§‹æ¸¸æˆ</strong></p>
            <p>W/A/S/D ä¹Ÿå¯æ§åˆ¶æ–¹å‘</p>
          </div>
        </div>
      </div>

      <section class="actions">
        <button id="restart" type="button">é‡æ–°å¼€å§‹</button>
        <span class="tips">æ’å¢™æˆ–å’¬åˆ°è‡ªå·±ä¼šå¤±è´¥</span>
      </section>
    </main>

    <script>
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const overlay = document.getElementById('overlay');
      const restartBtn = document.getElementById('restart');

      const gridSize = 20;
      const tileCount = canvas.width / gridSize;
      const speed = 110;

      const dirMap = {
        ArrowUp: { x: 0, y: -1 },
        ArrowDown: { x: 0, y: 1 },
        ArrowLeft: { x: -1, y: 0 },
        ArrowRight: { x: 1, y: 0 },
        w: { x: 0, y: -1 },
        s: { x: 0, y: 1 },
        a: { x: -1, y: 0 },
        d: { x: 1, y: 0 }
      };

      let snake;
      let direction;
      let pendingDirection;
      let food;
      let score;
      let bestScore = Number(localStorage.getItem('snake-best') || '0');
      let running;
      let gameLoopTimer;

      bestEl.textContent = bestScore;

      function resetGame() {
        snake = [
          { x: 8, y: 12 },
          { x: 7, y: 12 },
          { x: 6, y: 12 }
        ];
        direction = { x: 1, y: 0 };
        pendingDirection = direction;
        food = randomFoodPosition();
        score = 0;
        running = false;
        scoreEl.textContent = score;
        overlay.innerHTML = '<div><p><strong>æŒ‰æ–¹å‘é”®å¼€å§‹æ¸¸æˆ</strong></p><p>W/A/S/D ä¹Ÿå¯æ§åˆ¶æ–¹å‘</p></div>';
        overlay.style.display = 'grid';
        clearInterval(gameLoopTimer);
        draw();
      }

      function randomFoodPosition() {
        let position;
        do {
          position = {
            x: Math.floor(Math.random() * tileCount),
            y: Math.floor(Math.random() * tileCount)
          };
        } while (snake?.some(seg => seg.x === position.x && seg.y === position.y));
        return position;
      }

      function startGameIfNeeded() {
        if (running) return;
        running = true;
        overlay.style.display = 'none';
        gameLoopTimer = setInterval(update, speed);
      }

      function changeDirection(next) {
        const isReverse = next.x === -direction.x && next.y === -direction.y;
        if (!isReverse) {
          pendingDirection = next;
        }
        startGameIfNeeded();
      }

      function update() {
        direction = pendingDirection;
        const head = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y
        };

        if (isCollision(head)) {
          return endGame();
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
          score += 10;
          scoreEl.textContent = score;
          food = randomFoodPosition();
        } else {
          snake.pop();
        }

        draw();
      }

      function isCollision(head) {
        const hitWall = head.x < 0 || head.y < 0 || head.x >= tileCount || head.y >= tileCount;
        const hitSelf = snake.some(seg => seg.x === head.x && seg.y === head.y);
        return hitWall || hitSelf;
      }

      function endGame() {
        clearInterval(gameLoopTimer);
        running = false;
        if (score > bestScore) {
          bestScore = score;
          bestEl.textContent = bestScore;
          localStorage.setItem('snake-best', String(bestScore));
        }
        overlay.innerHTML = `<div><p><strong>æ¸¸æˆç»“æŸï¼å¾—åˆ† ${score}</strong></p><p>æŒ‰æ–¹å‘é”®æˆ–ç‚¹å‡»â€œé‡æ–°å¼€å§‹â€å†æ¥ä¸€å±€</p></div>`;
        overlay.style.display = 'grid';
      }

      function drawGrid() {
        ctx.strokeStyle = 'rgba(255,255,255,0.07)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= tileCount; i++) {
          const line = i * gridSize;
          ctx.beginPath();
          ctx.moveTo(line, 0);
          ctx.lineTo(line, canvas.height);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, line);
          ctx.lineTo(canvas.width, line);
          ctx.stroke();
        }
      }

      function drawCell({ x, y }, color, radius = 4) {
        const px = x * gridSize;
        const py = y * gridSize;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(px + 1, py + 1, gridSize - 2, gridSize - 2, radius);
        ctx.fill();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawCell(food, '#f472b6', 6);
        snake.forEach((segment, index) => {
          drawCell(segment, index === 0 ? '#7dffa5' : '#22c55e');
        });
      }

      document.addEventListener('keydown', (event) => {
        const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
        const next = dirMap[key];
        if (!next) return;
        event.preventDefault();
        changeDirection(next);
      });

      restartBtn.addEventListener('click', resetGame);

      resetGame();
    </script>
  </body>
</html>
